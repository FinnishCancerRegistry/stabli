% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stat_table_make.R
\name{stat_table_make}
\alias{stat_table_make}
\alias{stat_table_make_from_expr}
\title{Make \code{stat_table}}
\usage{
stat_table_make_from_expr(
  expr,
  meta_expr = NULL,
  dataset_nm = "dataset",
  arg_by_nm = "by",
  arg_subset_nm = "subset",
  arg_by_style_nm = "by_style",
  stratification_vame = NULL,
  eval_env = NULL,
  calling_env = NULL
)
}
\arguments{
\item{expr}{\verb{[name, call]} (no default)

An R expression to evaluate for one stratum in your dataset.
E.g. \code{quote(list(n = .N, mu = mean(my_col)))}.}

\item{meta_expr}{\verb{[NULL, name, call]} (default \code{NULL})

An R expression to evaluate which produces the \code{stat_table} metadata
object. \code{NULL} causes an internally defined default to be used.}

\item{dataset_nm}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{arg_by_nm}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{arg_subset_nm}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{arg_by_style_nm}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{stratification_vame}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{eval_env}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{calling_env}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}
}
\description{
Functions to make it easy to write functions which produce \code{stat_table}
objects.
}
\section{Functions}{

\strong{stabli::stat_table_make_from_expr}

\code{stabli::stat_table_make_from_expr} is a general solution for writing
functions to produce \code{stat_table} objects. You can essentially write
a wrapper for this function with a custom \code{expr} to evaluate in every
stratum which then returns a \code{stat_table} object. The following steps are
performed:
\itemize{
\item \code{stabli::handle_arg_by_et_subset_et_by_style_inplace} is called.
\item A \code{data.table} expression is generated based on whether stratification
and / or subsetting is necessary. E.g. \code{dataset[i = subset, j = .N]},
if \code{expr = quote(.N)}.
\item The expression is evaluated in \code{eval_env}.
\item The result is at this point a \code{data.table}. The \code{stat_table} metadata is
evaluated next. By default \code{stratum_col_nms} and \code{value_col_nms}
are inferred from \code{by} and the column names of the result at this point.
Non-default \code{meta_expr} is evaluated in \code{eval_env}.
\item \code{stabli::stat_table_set} is called on the result with the collected
metadata. The resulting \code{stat_table} is returned.
}
}

\section{News for version 0.4.0}{


\code{stabli::stat_table_make_from_expr} gains argument
\code{stratification_vame}.
}

\section{News for version 0.3.0}{


New function \code{stabli::stat_table_make_from_expr}.
}

\examples{

# stabli::stat_table_make_from_expr

# stabli::stat_table_make_from_expr
my_stat_fun_1 <- function(
  x,
  by = NULL,
  subset = NULL,
  by_style = NULL
) {
  out <- stabli:::stat_table_make_from_expr(
    expr = quote(list(n = .N, mu = mean(b))),
    meta_expr = quote(list(
      stratum_col_nms = as.character(names(by)),
      value_col_nms = c("n", "mu")
    )),
    dataset_nm = "x"
  )
  return(out[])
}

my_stat_fun_2 <- function(
  x,
  by = NULL,
  subset = NULL,
  by_style = NULL
) {
  out <- stabli:::stat_table_make_from_expr(
    expr = quote({
      dt <- data.table::data.table(
        interval_no = 1:5,
        time_lo = 0:4,
        time_up = 1:5,
        n = NA_integer_,
        d = NA_integer_
      )
      if (.N > 0) {
        data.table::set(
          dt,
          j = c("n", "d"),
          value = list(
            n = sample(size = 5, x = 10L, replace = TRUE),
            d = sample(size = 5, x = 3L, replace = TRUE)
          )
        )
      }
      dt[]
    }),
    meta_expr = quote(list(
      stratum_col_nms = c(names(by), "interval_no"),
      value_col_nms = c("n", "d")
    )),
    dataset_nm = "x"
  )
  return(out[])
}

# If you don't some args in your function
my_stat_fun_3 <- function(
  x,
  by = NULL
) {
  subset <- NULL
  by_style <- NULL
  out <- stabli:::stat_table_make_from_expr(
    expr = quote(list(n = .N, mu = mean(b))),
    meta_expr = quote(list(
      stratum_col_nms = as.character(names(by)),
      value_col_nms = c("n", "mu")
    )),
    dataset_nm = "x"
  )
  return(out[])
}

my_dataset <- data.table::data.table(
  a = sample(1:5, size = 1e6L, replace = TRUE)
)
my_dataset[j = "b" := a + runif(n = 1e6L)]

st_1 <- my_stat_fun_1(
  x = my_dataset,
  by = "a",
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_1) == 5)

st_2 <- my_stat_fun_2(
  x = my_dataset,
  by = "a",
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_2) == 5 * 5)

st_3 <- my_stat_fun_2(
  x = my_dataset,
  by = NULL,
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_3) == 5)

st_4 <- my_stat_fun_1(
  x = my_dataset,
  by = NULL,
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_4) == 1)

st_5 <- my_stat_fun_1(
  x = my_dataset,
  by = list(a = 1:6),
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_5) == 6)

st_6 <- my_stat_fun_2(
  x = my_dataset,
  by = list(a = 1:6),
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_6) == 6 * 5)

st_7 <- my_stat_fun_3(
  x = my_dataset,
  by = "a"
)
stopifnot(nrow(st_7) == 5)

}
