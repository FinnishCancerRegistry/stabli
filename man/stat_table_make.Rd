% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stat_table_make.R
\name{stat_table_make}
\alias{stat_table_make}
\alias{stat_table_make_from_expr}
\alias{stat_table_make_from_by_list}
\title{Make \code{stat_table}}
\usage{
stat_table_make_from_expr(
  expr,
  meta_expr = NULL,
  dataset_nm = "dataset",
  arg_by_nm = "by",
  arg_subset_nm = "subset",
  arg_by_style_nm = "by_style",
  stratification_vame = NULL,
  eval_env = NULL,
  calling_env = NULL
)

stat_table_make_from_by_list(
  fun_nm,
  dataset,
  by_list,
  subset = NULL,
  by_style = NULL,
  arg_list = NULL,
  optional_steps = NULL,
  harmonisation_vame = NULL,
  stratification_vame = NULL
)
}
\arguments{
\item{expr}{\verb{[name, call]} (no default)

An R expression to evaluate for one stratum in your dataset.
E.g. \code{quote(list(n = .N, mu = mean(my_col)))}.}

\item{meta_expr}{\verb{[NULL, name, call]} (default \code{NULL})

An R expression to evaluate which produces the \code{stat_table} metadata
object. \code{NULL} causes an internally defined default to be used.}

\item{dataset_nm}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{arg_by_nm}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{arg_subset_nm}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{arg_by_style_nm}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{stratification_vame}{\verb{[VariableMetadata, NULL]} (default \code{NULL})

Passed to \verb{[handle_arg_by]}.}

\item{eval_env}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{calling_env}{See \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{fun_nm}{\verb{[character]} (no default)

Must be the name of a function, e.g. \code{"my_fun"}, \code{"mypkg::my_fun"}.
The function must return a \code{stat_table} --- see \verb{[stat_table]}.}

\item{by_list}{\verb{[list]} (no default)

Each element is a passed in turn to function named \code{fun_nm}
as argument \code{by}.}

\item{subset}{Handled by \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{by_style}{Handled by \verb{[handle_arg_by_et_subset_et_by_style_inplace]}.}

\item{arg_list}{\verb{[NULL, list]} (default \code{NULL})

Additional arguments to pass to function named \code{fun_nm}.
\itemize{
\item \code{NULL}: Don't pass additional arguments.
\item \code{list}: These arguments will be included in call to \code{fun_nm}.
See detailed description of steps performed to see how this works.
}}

\item{optional_steps}{\verb{[NULL, list]} (default \code{NULL})
\itemize{
\item \code{NULL}: No additional optional steps are run.
\item \code{list}: This named list of functions is used to perform optional steps
during run. See detailed description of steps performed by function
to see how this can be used.
}}

\item{harmonisation_vame}{\verb{[NULL, VariableMetadata]} (default \code{NULL})

Contains metadata for harmonising results.
See \code{?vame::VariableMetadata}.
\itemize{
\item \code{NULL}: No harmonisation attempted.
\item \code{VariableMetadata}:
See the detailed description of \code{stabli::stat_table_make_from_by_list}.
}}
}
\value{
\strong{stabli::stat_table_make_from_by_list}

Returns a \code{data.table} with the additional class \code{stat_table}.
}
\description{
Functions to make it easy to write functions which produce \code{stat_table}
objects.
}
\section{Functions}{

\strong{stabli::stat_table_make_from_expr}

\code{stabli::stat_table_make_from_expr} is a general solution for writing
functions to produce \code{stat_table} objects. You can essentially write
a wrapper for this function with a custom \code{expr} to evaluate in every
stratum which then returns a \code{stat_table} object. The following steps are
performed:
\itemize{
\item \code{stabli::handle_arg_by_et_subset_et_by_style_inplace} is called.
\item A \code{data.table} expression is generated based on whether stratification
and / or subsetting is necessary. E.g. \code{dataset[i = subset, j = .N]},
if \code{expr = quote(.N)}.
\item The expression is evaluated in \code{eval_env}.
\item The result is at this point a \code{data.table}. The \code{stat_table} metadata is
evaluated next. By default \code{stratum_col_nms} and \code{value_col_nms}
are inferred from \code{by} and the column names of the result at this point.
Non-default \code{meta_expr} is evaluated in \code{eval_env}.
\item \code{stabli::stat_table_set} is called on the result with the collected
metadata. The resulting \code{stat_table} is returned.
}


\strong{stabli::stat_table_make_from_by_list}

\code{stabli::stat_table_make_from_by_list} performs the following steps:
\itemize{
\item Run \code{optional_steps[["on_entry"]](env = main_env)} if that \code{optional_steps} element
exists. \code{main_env} is the evaluation environment of
\code{stabli::stat_table_make_from_by_list}.
\item Run \code{on.exit(optional_steps[["on_exit"]](env = main_env))} if that
\code{optional_steps} element exists.
\item Run \code{stabli::handle_arg_by_et_subset_et_by_style_inplace}.
\item Run \code{optional_steps[["pre_lapply"]](env = main_env)} if that \code{optional_steps}
element exists.
\item Run \code{lapply} on \code{by_list}. For each element
\itemize{
\item Run \code{optional_steps[["lapply_on_entry"]](env = anon_fun_env)}
if that \code{optional_steps} element exists. \code{anon_fun_env} is the
evaluation environment of the anonymous function passed to
\code{lapply} defined in the body of
\code{stabli::stat_table_make_from_by_list}.
\item Run \code{on.exit(optional_steps[["lapply_on_exit"]](env = anon_fun_env))}
if that \code{optional_steps} element exists.
\item Create argument list \code{arg_list_i} for calling function named
\code{fun_nm}. It is created by collecting \code{dataset}, \code{subset}, \code{by}
(current element of \code{by_list}), and
\code{by_style} into a list, and by appending argument
\code{arg_list} to it. \code{by} is additionally processed by
\code{stabli::handle_arg_by}.
\item If \code{arg_list_i[["by"]]} is at this point a \code{data.table} and
contains any \code{NA} strata, those \code{NA} strata are dropped.
\code{arg_list_i[["by"]]} contains \code{NA} strata at least if
\code{stratification_vame}
allows for \code{NA} values for \code{by}.
\item Run \code{optional_steps[["lapply_pre_stat_fun_call"]](env = anon_fun_env)}
if that \code{optional_steps} element exists.
\item Call function named \code{fun_nm} using \code{arg_list_i}.
\item Run \code{optional_steps[["lapply_post_stat_fun_call"]](env = anon_fun_env)}
if that \code{optional_steps} element exists.
\item If \code{harmonisation_vame} is not \code{NULL}:
\itemize{
\item Run \code{optional_steps[["lapply_pre_harmonisation_call"]](env = anon_fun_env)}
if that \code{optional_steps} element exists.
\item Call \code{harmonisation_vame@vame_harmonise_dt} on the
partial statistics table.
\item Run \code{optional_steps[["lapply_post_harmonisation_call"]](env = anon_fun_env)}
if that \code{optional_steps} element exists.
}
}
\item Run \code{optional_steps[["post_lapply"]](env = main_env)}
if that \code{optional_steps} element exists.
}

Returns a \code{data.table} with the additional class \code{stat_table}.
}

\section{News for version 0.4.0}{


\code{stabli::stat_table_make_from_expr} gains argument
\code{stratification_vame}.



\code{stabli::stat_table_make_from_by_list} arg \code{optional_steps} elem
gains element \code{lapply_pre_harmonisation_call}.

\code{stabli::stat_table_make_from_by_list} arg \code{optional_steps} elem
gains element \code{lapply_post_harmonisation_call}.
}

\section{News for version 0.3.0}{


New function \code{stabli::stat_table_make_from_expr}.
}

\examples{

# stabli::stat_table_make_from_expr

# stabli::stat_table_make_from_expr
my_stat_fun_1 <- function(
  x,
  by = NULL,
  subset = NULL,
  by_style = NULL
) {
  out <- stabli:::stat_table_make_from_expr(
    expr = quote(list(n = .N, mu = mean(b))),
    meta_expr = quote(list(
      stratum_col_nms = as.character(names(by)),
      value_col_nms = c("n", "mu")
    )),
    dataset_nm = "x"
  )
  return(out[])
}

my_stat_fun_2 <- function(
  x,
  by = NULL,
  subset = NULL,
  by_style = NULL
) {
  out <- stabli:::stat_table_make_from_expr(
    expr = quote({
      dt <- data.table::data.table(
        interval_no = 1:5,
        time_lo = 0:4,
        time_up = 1:5,
        n = NA_integer_,
        d = NA_integer_
      )
      if (.N > 0) {
        data.table::set(
          dt,
          j = c("n", "d"),
          value = list(
            n = sample(size = 5, x = 10L, replace = TRUE),
            d = sample(size = 5, x = 3L, replace = TRUE)
          )
        )
      }
      dt[]
    }),
    meta_expr = quote(list(
      stratum_col_nms = c(names(by), "interval_no"),
      value_col_nms = c("n", "d")
    )),
    dataset_nm = "x"
  )
  return(out[])
}

# If you don't some args in your function
my_stat_fun_3 <- function(
  x,
  by = NULL
) {
  subset <- NULL
  by_style <- NULL
  out <- stabli:::stat_table_make_from_expr(
    expr = quote(list(n = .N, mu = mean(b))),
    meta_expr = quote(list(
      stratum_col_nms = as.character(names(by)),
      value_col_nms = c("n", "mu")
    )),
    dataset_nm = "x"
  )
  return(out[])
}

my_dataset <- data.table::data.table(
  a = sample(1:5, size = 1e6L, replace = TRUE)
)
my_dataset[j = "b" := a + runif(n = 1e6L)]

st_1 <- my_stat_fun_1(
  x = my_dataset,
  by = "a",
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_1) == 5)

st_2 <- my_stat_fun_2(
  x = my_dataset,
  by = "a",
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_2) == 5 * 5)

st_3 <- my_stat_fun_2(
  x = my_dataset,
  by = NULL,
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_3) == 5)

st_4 <- my_stat_fun_1(
  x = my_dataset,
  by = NULL,
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_4) == 1)

st_5 <- my_stat_fun_1(
  x = my_dataset,
  by = list(a = 1:6),
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_5) == 6)

st_6 <- my_stat_fun_2(
  x = my_dataset,
  by = list(a = 1:6),
  subset = data.table::data.table(a = 3:5),
  by_style = "keep_empty"
)
stopifnot(nrow(st_6) == 6 * 5)

st_7 <- my_stat_fun_3(
  x = my_dataset,
  by = "a"
)
stopifnot(nrow(st_7) == 5)

}
